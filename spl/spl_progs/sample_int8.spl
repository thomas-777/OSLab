//fork 
breakpoint;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13] = SP;

SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11] * 512 - 1;


//Set mode flag to system no
[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=8;

R1=1;
call MOD_1;

alias newPid R2;
newPid=R0;

//IF pid not available
if(newPid==-1) then
    R0=-1;
    [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=0;
    ireturn;
endif;
breakpoint;
alias currentPID R3;
currentPID=[SYSTEM_STATUS_TABLE+1];

//If heap is not yet allocated
if([PAGE_TABLE_BASE+20*currentPID+4]==-1) then
    multipush(R2,R3);
    R1=1;
    call MOD_2;
    multipop(R2,R3);
    [PAGE_TABLE_BASE+20*currentPID+4]=R0;
    [PAGE_TABLE_BASE+20*currentPID+5]="0110";
    

    multipush(R2,R3);
    R1=1;
    call MOD_2;
     multipop(R2,R3);
    [PAGE_TABLE_BASE+20*currentPID+6]=R0;
    [PAGE_TABLE_BASE+20*currentPID+7]="0110";
   
endif;
breakpoint;
//stack for child process
multipush(R2,R3);
R1=1;
call MOD_2;
multipop(R2,R3);
[PAGE_TABLE_BASE + newPid*20 + 16]=R0;
[PAGE_TABLE_BASE + newPid*20 + 17]="0110";

multipush(R2,R3);
R1=1;
call MOD_2;
multipop(R2,R3);
[PAGE_TABLE_BASE + newPid*20 + 18]=R0;
[PAGE_TABLE_BASE + newPid*20 + 19]="0110";

breakpoint;

//user area page for child
multipush(R2,R3);
R1=1;
call MOD_2;
multipop(R2,R3);
[PROCESS_TABLE + newPid*16 + 11]=R0;


//copy contents of the parent process
alias userID R4;
alias swapflag R5;
alias userareaswapstatus R6;
alias inode_index R7;
alias uptr R8;
userID=[PROCESS_TABLE + currentPID*16 + 3];
swapflag=[PROCESS_TABLE + currentPID*16 + 6];
userareaswapstatus=[PROCESS_TABLE + currentPID*16 + 10];
inode_index=[PROCESS_TABLE + currentPID*16 + 7];
uptr=[PROCESS_TABLE + currentPID*16 + 13];
[PROCESS_TABLE + newPid*16 + 3]=userID;
[PROCESS_TABLE + newPid*16 + 6]=swapflag;
[PROCESS_TABLE + newPid*16 + 10]=userareaswapstatus;
[PROCESS_TABLE + newPid*16 + 7]=inode_index;
[PROCESS_TABLE + newPid*16 + 13]=uptr;


//setup process table for child
[PROCESS_TABLE + newPid*16 + 9]=0;
//TICK
[PROCESS_TABLE + newPid*16 + 0]=0;
//KPTR
[PROCESS_TABLE + newPid*16 + 12]=0;
//PPID
[PROCESS_TABLE + newPid*16 + 2]=currentPID;
[PROCESS_TABLE + newPid * 16 + 4] = CREATED;


// initialization per process resourse table child
alias i R4;
i = 512 - 16;
while (i < 512) do
    [[PROCESS_TABLE + newPid * 16 + 11] * 512 + i] = [[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11] * 512 + i];
    i = i + 1;
endwhile;

breakpoint;
// initialization per process DISK MAP table child
i = 2;
while (i < 10) do
    [DISK_MAP_TABLE+10*newPid+i] = [DISK_MAP_TABLE+10*currentPID+i];
    i = i + 1;
endwhile;

//initialize page table
i=0;
while(i<16) do
    [PAGE_TABLE_BASE + newPid*20 + i] = [PAGE_TABLE_BASE + currentPID*20 + i];
    [PAGE_TABLE_BASE + newPid*20 + i+1] = [PAGE_TABLE_BASE + currentPID*20 + i+1];
    if([PAGE_TABLE_BASE + newPid*20 + i]!=-1) then
        [MEMORY_FREE_LIST + [PAGE_TABLE_BASE + newPid*20 + i]*2] = [MEMORY_FREE_LIST + [PAGE_TABLE_BASE + newPid*20 + i]*2]+1;
    endif;
    i=i+2;

endwhile;
breakpoint;
//copy stac contenrts
alias oldStack R5;
alias newStack R6;

oldStack = [PAGE_TABLE_BASE+20*currentPID + 16];
newStack = [PAGE_TABLE_BASE+20*newPid + 16];
i = 0;
while (i < 512) do
    [newStack * 512 + i] = [oldStack * 512 + i];
    i = i + 1;
endwhile;

oldStack = [PAGE_TABLE_BASE+20*currentPID + 18];
newStack = [PAGE_TABLE_BASE+20*newPid + 18];
i = 0;
while (i < 512) do
    [newStack * 512 + i] = [oldStack * 512 + i];
    i = i + 1;
endwhile;

//push bp to the child kernel stack
[[PROCESS_TABLE + newPid * 16 + 11] * 512] = BP;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

breakpoint;
//Return values
alias userSP R7;
userSP=[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13];
[[PAGE_TABLE_BASE+20*currentPID + 2 * ((userSP - 1) / 512)] * 512 + (userSP - 1) % 512] = newPid;
[[PAGE_TABLE_BASE+20*newPid + 2 * ((userSP - 1) / 512)] * 512 + (userSP - 1) % 512] = 0;

SP=[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13];
breakpoint;
ireturn;

